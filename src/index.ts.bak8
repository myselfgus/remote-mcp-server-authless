import { McpAgent } from "agents/mcp";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { Connection } from "partyserver";
import { z } from "zod";

// Cloudflare Access authentication
// NOTE: When Cloudflare Access is configured in the dashboard, it intercepts ALL requests
// BEFORE they reach the Worker and handles authentication/authorization.
// The Worker does NOT need to validate JWT - if the request reaches the Worker,
// it means Cloudflare Access already validated it.
//
// This flag just tracks whether we EXPECT Cloudflare Access to be enabled in the dashboard.
interface CloudflareAccessConfig {
	enabled: boolean;
}

async function validateCloudflareAccess(
	request: Request,
	config: CloudflareAccessConfig,
): Promise<Response | null> {
	// If Cloudflare Access is enabled in the dashboard, it handles everything.
	// The Worker doesn't need to do any validation - just let requests through.
	// Cloudflare Access validates JWT, checks policies, and blocks unauthorized requests
	// BEFORE they reach this code.
	return null; // Always allow - Cloudflare Access in dashboard handles security
}

// Storage interface for MCP server configurations
interface MCPServerConfig {
	name: string;
	version: string;
	description: string;
	tools: ToolDefinition[];
	resources: ResourceDefinition[];
	prompts: PromptDefinition[];
	wranglerConfig: WranglerConfig;
	createdAt: number;
	updatedAt: number;
}

interface ToolDefinition {
	name: string;
	description: string;
	parameters: Record<string, any>;
	implementation: string;
}

interface ResourceDefinition {
	uri: string;
	name: string;
	description: string;
	mimeType: string;
	implementation: string;
}

interface PromptDefinition {
	name: string;
	description: string;
	arguments: Array<{ name: string; description: string; required: boolean }>;
	template: string;
}

interface WranglerConfig {
	name: string;
	compatibilityDate: string;
	compatibilityFlags: string[];
	routes?: string[];
	vars?: Record<string, any>;
}

// Database schema types for SQLite persistence
interface DatabaseSchema {
	mcp_servers: {
		id: string;
		name: string;
		version: string;
		description: string;
		created_at: number;
		updated_at: number;
		wrangler_config: string; // JSON
	};
	mcp_tools: {
		id: number;
		server_id: string;
		name: string;
		description: string;
		parameters: string; // JSON
		implementation: string;
		created_at: number;
	};
	mcp_resources: {
		id: number;
		server_id: string;
		uri: string;
		name: string;
		description: string;
		mime_type: string;
		implementation: string;
		created_at: number;
	};
	mcp_prompts: {
		id: number;
		server_id: string;
		name: string;
		description: string;
		arguments: string; // JSON
		template: string;
		created_at: number;
	};
	cleanup_requests: {
		id: string;
		requested_at: number;
		servers_to_delete: string; // JSON array
		status: "pending" | "approved" | "rejected";
		responded_at: number | null;
	};
	mcp_client_connections: {
		id: string;
		name: string;
		url: string;
		status: "connected" | "disconnected" | "error";
		last_sync: number;
		capabilities: string | null; // JSON
		tools_count: number;
		resources_count: number;
		created_at: number;
	};
}

// State management interface
interface MetaMCPState {
	// Server statistics
	totalServers: number;
	totalTools: number;
	totalResources: number;
	totalPrompts: number;

	// Recent activity
	lastServerCreated: {
		name: string;
		timestamp: number;
	} | null;
	lastServerUpdated: {
		name: string;
		timestamp: number;
	} | null;
	lastServerDeleted: {
		name: string;
		timestamp: number;
	} | null;

	// Cleanup state
	pendingCleanupRequests: number;
	lastCleanupRun: number | null;
	nextScheduledCleanup: number | null;

	// MCP client connections
	connectedMCPServers: Array<{
		name: string;
		url: string;
		status: "connected" | "disconnected" | "error";
		lastSync: number;
	}>;

	// System health
	databaseHealth: "healthy" | "degraded" | "error";
	lastHealthCheck: number;
}

// Cleanup configuration
interface CleanupConfig {
	enabled: boolean;
	daysThreshold: number;
	checkIntervalMs: number;
	requireConfirmation: boolean;
	confirmationTimeoutMs: number;
}

const DEFAULT_CLEANUP_CONFIG: CleanupConfig = {
	enabled: true,
	daysThreshold: 30,
	checkIntervalMs: 24 * 60 * 60 * 1000, // 24 hours
	requireConfirmation: true,
	confirmationTimeoutMs: 48 * 60 * 60 * 1000, // 48 hours
};

// Define our Meta-MCP agent that creates other MCP servers
export class MetaMCP extends McpAgent<unknown, MetaMCPState> {
	server = new McpServer({
		name: "MCP Remote Server Builder",
		version: "1.0.0",
	});

	// Initialize state
	initialState: MetaMCPState = {
		totalServers: 0,
		totalTools: 0,
		totalResources: 0,
		totalPrompts: 0,
		lastServerCreated: null,
		lastServerUpdated: null,
		lastServerDeleted: null,
		pendingCleanupRequests: 0,
		lastCleanupRun: null,
		nextScheduledCleanup: null,
		connectedMCPServers: [],
		databaseHealth: "healthy",
		lastHealthCheck: Date.now(),
	};

	private isDbInitialized = false;

	async init() {
		// Initialize database first
		await this.initializeDatabase();

		// Initialize cleanup scheduling
		const config = await this.ctx.storage.get<CleanupConfig>("cleanup_config");
		if (!config) {
			await this.ctx.storage.put("cleanup_config", DEFAULT_CLEANUP_CONFIG);
		}

		// Tool 1: Create a new MCP server
		this.server.tool(
			"create_mcp_server",
			{
				name: z.string().describe("Name of the MCP server (e.g., 'weather-server')"),
				version: z.string().default("1.0.0").describe("Version of the server"),
				description: z.string().describe("Description of what the MCP server does"),
			},
			async ({ name, version, description }) => {
				// Validate name format
				const nameRegex = /^[a-z0-9-]+$/;
				if (!nameRegex.test(name)) {
					return {
						content: [
							{
								type: "text",
								text: "Error: Server name must contain only lowercase letters, numbers, and hyphens",
							},
						],
					};
				}

				const serverId = name;

				const existingServer = await this.getServerFromDB(serverId);
				if (existingServer !== null) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${name}' already exists. Use update tools to modify it.`,
							},
						],
					};
				}

				const config: MCPServerConfig = {
					name,
					version,
					description,
					tools: [],
					resources: [],
					prompts: [],
					wranglerConfig: {
						name,
						compatibilityDate: "2025-03-10",
						compatibilityFlags: ["nodejs_compat"],
					},
					createdAt: Date.now(),
					updatedAt: Date.now(),
				};

				await this.saveServerToDB(serverId, config);
				await this.notifyServerCreated(name);

				return {
					content: [
						{
							type: "text",
							text: `Successfully created MCP server '${name}'!\n\nNext steps:\n1. Add tools using add_mcp_tool\n2. Optionally add resources using add_mcp_resource\n3. Optionally add prompts using add_mcp_prompt\n4. Configure deployment using configure_wrangler\n5. Generate code using get_mcp_server_code\n6. Deploy using deploy_mcp_server`,
						},
					],
				};
			},
		);

		// Tool 2: Add a tool to an MCP server
		this.server.tool(
			"add_mcp_tool",
			{
				serverId: z.string().describe("ID of the MCP server (server name)"),
				toolName: z.string().describe("Name of the tool"),
				description: z.string().describe("Description of what the tool does"),
				parameters: z
					.record(z.any())
					.describe(
						"Tool parameters as JSON object with Zod schema definitions (e.g., {\"city\": {\"type\": \"string\", \"description\": \"City name\"}})",
					),
				implementation: z
					.string()
					.describe(
						"JavaScript implementation code that will be executed (receives parameters, returns {content: [{type: 'text', text: string}]})",
					),
			},
			async ({ serverId, toolName, description, parameters, implementation }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found. Create it first using create_mcp_server.`,
							},
						],
					};
				}

				// Check if tool already exists
				const existingIndex = config.tools.findIndex((t) => t.name === toolName);
				if (existingIndex >= 0) {
					config.tools[existingIndex] = {
						name: toolName,
						description,
						parameters,
						implementation,
					};
				} else {
					config.tools.push({
						name: toolName,
						description,
						parameters,
						implementation,
					});
				}

				config.updatedAt = Date.now();
				await this.saveServerToDB(serverId, config);
				await this.notifyServerUpdated(config.name);

				return {
					content: [
						{
							type: "text",
							text: `Successfully ${existingIndex >= 0 ? "updated" : "added"} tool '${toolName}' to server '${serverId}'!\n\nTool: ${toolName}\nDescription: ${description}\nParameters: ${JSON.stringify(parameters, null, 2)}`,
						},
					],
				};
			},
		);

		// Tool 3: Add a resource to an MCP server
		this.server.tool(
			"add_mcp_resource",
			{
				serverId: z.string().describe("ID of the MCP server"),
				uri: z.string().describe("URI of the resource (e.g., 'file:///data/config.json')"),
				name: z.string().describe("Name of the resource"),
				description: z.string().describe("Description of the resource"),
				mimeType: z.string().default("text/plain").describe("MIME type of the resource"),
				implementation: z
					.string()
					.describe("JavaScript code to generate the resource content (returns string)"),
			},
			async ({ serverId, uri, name, description, mimeType, implementation }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const existingIndex = config.resources.findIndex((r) => r.uri === uri);
				if (existingIndex >= 0) {
					config.resources[existingIndex] = {
						uri,
						name,
						description,
						mimeType,
						implementation,
					};
				} else {
					config.resources.push({
						uri,
						name,
						description,
						mimeType,
						implementation,
					});
				}

				config.updatedAt = Date.now();
				await this.saveServerToDB(serverId, config);
				await this.notifyServerUpdated(config.name);

				return {
					content: [
						{
							type: "text",
							text: `Successfully ${existingIndex >= 0 ? "updated" : "added"} resource '${name}' to server '${serverId}'!`,
						},
					],
				};
			},
		);

		// Tool 4: Add a prompt to an MCP server
		this.server.tool(
			"add_mcp_prompt",
			{
				serverId: z.string().describe("ID of the MCP server"),
				promptName: z.string().describe("Name of the prompt"),
				description: z.string().describe("Description of what the prompt does"),
				arguments: z
					.array(
						z.object({
							name: z.string(),
							description: z.string(),
							required: z.boolean(),
						}),
					)
					.default([])
					.describe("Array of prompt arguments"),
				template: z
					.string()
					.describe(
						"Prompt template with argument placeholders (e.g., 'Analyze {{code}} for security issues')",
					),
			},
			async ({ serverId, promptName, description, arguments: args, template }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const existingIndex = config.prompts.findIndex((p) => p.name === promptName);
				if (existingIndex >= 0) {
					config.prompts[existingIndex] = {
						name: promptName,
						description,
						arguments: args,
						template,
					};
				} else {
					config.prompts.push({
						name: promptName,
						description,
						arguments: args,
						template,
					});
				}

				config.updatedAt = Date.now();
				await this.saveServerToDB(serverId, config);
				await this.notifyServerUpdated(config.name);

				return {
					content: [
						{
							type: "text",
							text: `Successfully ${existingIndex >= 0 ? "updated" : "added"} prompt '${promptName}' to server '${serverId}'!`,
						},
					],
				};
			},
		);

		// Tool 5: Configure Wrangler deployment settings
		this.server.tool(
			"configure_wrangler",
			{
				serverId: z.string().describe("ID of the MCP server"),
				routes: z.array(z.string()).optional().describe("Custom routes for the worker"),
				vars: z.record(z.any()).optional().describe("Environment variables"),
				compatibilityDate: z.string().optional().describe("Compatibility date"),
			},
			async ({ serverId, routes, vars, compatibilityDate }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				if (routes) config.wranglerConfig.routes = routes;
				if (vars) config.wranglerConfig.vars = vars;
				if (compatibilityDate) config.wranglerConfig.compatibilityDate = compatibilityDate;

				config.updatedAt = Date.now();
				await this.saveServerToDB(serverId, config);
				await this.notifyServerUpdated(config.name);

				return {
					content: [
						{
							type: "text",
							text: `Successfully updated Wrangler configuration for '${serverId}'!\n\n${JSON.stringify(config.wranglerConfig, null, 2)}`,
						},
					],
				};
			},
		);

		// Tool 6: Get generated MCP server code
		this.server.tool(
			"get_mcp_server_code",
			{
				serverId: z.string().describe("ID of the MCP server"),
				fileType: z
					.enum(["index", "wrangler", "package", "all"])
					.default("all")
					.describe("Which file to generate: index.ts, wrangler.jsonc, package.json, or all"),
			},
			async ({ serverId, fileType }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const files: Record<string, string> = {};

				// Generate index.ts
				if (fileType === "index" || fileType === "all") {
					files["src/index.ts"] = this.generateIndexTs(config);
				}

				// Generate wrangler.jsonc
				if (fileType === "wrangler" || fileType === "all") {
					files["wrangler.jsonc"] = this.generateWranglerConfig(config);
				}

				// Generate package.json
				if (fileType === "package" || fileType === "all") {
					files["package.json"] = this.generatePackageJson(config);
				}

				const output = Object.entries(files)
					.map(([filename, content]) => `\n### ${filename}\n\`\`\`${filename.endsWith(".ts") ? "typescript" : "json"}\n${content}\n\`\`\``)
					.join("\n");

				return {
					content: [
						{
							type: "text",
							text: `Generated code for MCP server '${serverId}':\n${output}\n\nYou can now:\n1. Save these files to a new project directory\n2. Run 'npm install'\n3. Run 'npm run deploy' to deploy to Cloudflare Workers`,
						},
					],
				};
			},
		);

		// Tool 7: List all created servers
		this.server.tool(
			"list_mcp_servers",
			{},
			async () => {
				const servers = await this.listServersFromDB();

				if (servers.length === 0) {
					return {
						content: [
							{
								type: "text",
								text: "No MCP servers created yet. Use create_mcp_server to create one.",
							},
						],
					};
				}

				const serverList = servers
					.map(
						(s) =>
							`- **${s.name}** (v${s.version})\n  ${s.description}\n  Tools: ${s.tools.length}, Resources: ${s.resources.length}, Prompts: ${s.prompts.length}\n  Updated: ${new Date(s.updatedAt).toLocaleString()}`,
					)
					.join("\n\n");

				return {
					content: [
						{
							type: "text",
							text: `MCP Servers (${servers.length}):\n\n${serverList}`,
						},
					],
				};
			},
		);

		// Tool 8: Delete an MCP server
		this.server.tool(
			"delete_mcp_server",
			{
				serverId: z.string().describe("ID of the MCP server to delete"),
			},
			async ({ serverId }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const deleted = await this.deleteServerFromDB(serverId);
				if (deleted) {
					await this.notifyServerDeleted(config.name);
				}

				return {
					content: [
						{
							type: "text",
							text: `Successfully deleted MCP server '${serverId}'.`,
						},
					],
				};
			},
		);

		// Tool 9: Get server details
		this.server.tool(
			"get_mcp_server_details",
			{
				serverId: z.string().describe("ID of the MCP server"),
			},
			async ({ serverId }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const details = `
# MCP Server: ${config.name}

**Version:** ${config.version}
**Description:** ${config.description}
**Created:** ${new Date(config.createdAt).toLocaleString()}
**Updated:** ${new Date(config.updatedAt).toLocaleString()}

## Tools (${config.tools.length})
${config.tools.map((t) => `- **${t.name}**: ${t.description}`).join("\n") || "None"}

## Resources (${config.resources.length})
${config.resources.map((r) => `- **${r.name}** (${r.uri}): ${r.description}`).join("\n") || "None"}

## Prompts (${config.prompts.length})
${config.prompts.map((p) => `- **${p.name}**: ${p.description}`).join("\n") || "None"}

## Wrangler Config
\`\`\`json
${JSON.stringify(config.wranglerConfig, null, 2)}
\`\`\`
				`.trim();

				return {
					content: [
						{
							type: "text",
							text: details,
						},
					],
				};
			},
		);

		// Tool 10: Generate deployment command
		this.server.tool(
			"get_deployment_instructions",
			{
				serverId: z.string().describe("ID of the MCP server"),
			},
			async ({ serverId }) => {
				const config = await this.getServerFromDB(serverId);
				if (!config) {
					return {
						content: [
							{
								type: "text",
								text: `Error: Server '${serverId}' not found.`,
							},
						],
					};
				}

				const instructions = `
# Deployment Instructions for ${config.name}

## Step 1: Create Project Directory
\`\`\`bash
mkdir ${config.name}
cd ${config.name}
\`\`\`

## Step 2: Get Generated Code
Use the \`get_mcp_server_code\` tool with serverId="${serverId}" and fileType="all" to get all files.

## Step 3: Save Files
Save the generated files to your project:
- src/index.ts
- wrangler.jsonc
- package.json
- tsconfig.json (use the same from this project)

## Step 4: Install Dependencies
\`\`\`bash
npm install
\`\`\`

## Step 5: Test Locally
\`\`\`bash
npm run dev
\`\`\`

Visit http://localhost:8787/sse to test your MCP server locally.

## Step 6: Deploy to Cloudflare Workers
\`\`\`bash
npm run deploy
\`\`\`

Your MCP server will be deployed to:
\`${config.name}.<your-account>.workers.dev/sse\`

## Step 7: Connect to Claude Desktop
Add to your Claude Desktop config (~/.config/claude/claude_desktop_config.json):

\`\`\`json
{
  "mcpServers": {
    "${config.name}": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://${config.name}.<your-account>.workers.dev/sse"
      ]
    }
  }
}
\`\`\`

Restart Claude Desktop and your tools will be available!
				`.trim();

				return {
					content: [
						{
							type: "text",
							text: instructions,
						},
					],
				};
			},
		);

		// Tool 11: Cleanup old servers with user confirmation
		this.server.tool(
			"cleanup_old_servers",
			{
				daysThreshold: z.number().default(30).describe("Delete servers older than this many days"),
				dryRun: z.boolean().default(false).describe("Preview what would be deleted without actually deleting"),
			},
			async ({ daysThreshold, dryRun }) => {
				const servers = await this.listServersFromDB();
				const now = Date.now();
				const threshold = daysThreshold * 24 * 60 * 60 * 1000;

				const oldServers = servers.filter((s) => now - s.updatedAt > threshold);

				if (oldServers.length === 0) {
					return {
						content: [
							{
								type: "text",
								text: `No servers found older than ${daysThreshold} days.`,
							},
						],
					};
				}

				const serverList = oldServers
					.map(
						(s) =>
							`- ${s.name} (last updated: ${new Date(s.updatedAt).toLocaleString()}, ${Math.floor((now - s.updatedAt) / (24 * 60 * 60 * 1000))} days ago)`,
					)
					.join("\n");

				if (dryRun) {
					return {
						content: [
							{
								type: "text",
								text: `[DRY RUN] Found ${oldServers.length} servers older than ${daysThreshold} days:\n\n${serverList}\n\nRun without dryRun=true to proceed with deletion after confirmation.`,
							},
						],
					};
				}

				// Use elicitInput to ask user for confirmation
				try {
					const result = await this.elicitInput({
						message: `Found ${oldServers.length} servers older than ${daysThreshold} days:\n\n${serverList}\n\nDo you want to delete these servers? This action cannot be undone.`,
						requestedSchema: {
							type: "object",
							properties: {
								confirm: {
									type: "boolean",
									description: "Set to true to confirm deletion",
								},
							},
							required: ["confirm"],
						},
					});

					const confirmed = (result.content as { confirm: boolean }).confirm;

					if (!confirmed) {
						return {
							content: [
								{
									type: "text",
									text: "Cleanup cancelled by user.",
								},
							],
						};
					}

					// Delete confirmed servers
					let deletedCount = 0;
					for (const server of oldServers) {
						const deleted = await this.deleteServerFromDB(server.id);
						if (deleted) {
							await this.notifyServerDeleted(server.name);
							deletedCount++;
						}
					}

					// Update cleanup tracking
					await this.setState({
						...this.state,
						lastCleanupRun: Date.now(),
					});

					return {
						content: [
							{
								type: "text",
								text: `Successfully deleted ${deletedCount} old servers:\n\n${serverList}`,
							},
						],
					};
				} catch (error) {
					return {
						content: [
							{
								type: "text",
								text: `Error during cleanup: ${error instanceof Error ? error.message : String(error)}`,
							},
						],
					};
				}
			},
		);

		// Tool 12: Connect to an MCP server
		this.server.tool(
			"connect_to_mcp_server",
			{
				name: z.string().describe("Friendly name for this connection"),
				url: z.string().describe("URL of the MCP server to connect to"),
				transport: z
					.enum(["streamable-http", "sse", "auto"])
					.default("auto")
					.describe("Transport type to use (auto will detect the best option)"),
			},
			async ({ name, url, transport }) => {
				try {
					// Connect using MCPClientManager
					await this.mcp.connect(url, {
						transport: { type: transport },
					});

					// Store connection in database
					this.sql`
						INSERT INTO mcp_client_connections (name, url, transport, status, last_sync, created_at)
						VALUES (${name}, ${url}, ${transport}, 'connected', ${Date.now()}, ${Date.now()})
						ON CONFLICT(name) DO UPDATE SET
							url = ${url},
							transport = ${transport},
							status = 'connected',
							last_sync = ${Date.now()}
					`;

					// Update state
					const connections = this.state.connectedMCPServers || [];
					const existing = connections.findIndex((c) => c.name === name);
					if (existing >= 0) {
						connections[existing] = { name, url, status: "connected", lastSync: Date.now() };
					} else {
						connections.push({ name, url, status: "connected", lastSync: Date.now() });
					}

					await this.setState({
						...this.state,
						connectedMCPServers: connections,
					});

					return {
						content: [
							{
								type: "text",
								text: `Successfully connected to MCP server '${name}' at ${url} using ${transport} transport.`,
							},
						],
					};
				} catch (error) {
					// Update connection status to error
					this.sql`
						UPDATE mcp_client_connections
						SET status = 'error', last_sync = ${Date.now()}
						WHERE name = ${name}
					`;

					return {
						content: [
							{
								type: "text",
								text: `Error connecting to MCP server '${name}': ${error instanceof Error ? error.message : String(error)}`,
							},
						],
					};
				}
			},
		);

		// Tool 13: List connected MCP servers
		this.server.tool(
			"list_connected_mcp_servers",
			{},
			async () => {
				const connections = this.sql<{
					name: string;
					url: string;
					transport: string;
					status: string;
					last_sync: number;
					created_at: number;
				}>`SELECT * FROM mcp_client_connections ORDER BY created_at DESC`;

				if (connections.length === 0) {
					return {
						content: [
							{
								type: "text",
								text: "No MCP servers connected yet. Use connect_to_mcp_server to connect to an MCP server.",
							},
						],
					};
				}

				const connectionList = connections
					.map(
						(c) =>
							`- **${c.name}**\n  URL: ${c.url}\n  Transport: ${c.transport}\n  Status: ${c.status}\n  Last sync: ${new Date(c.last_sync).toLocaleString()}\n  Connected: ${new Date(c.created_at).toLocaleString()}`,
					)
					.join("\n\n");

				return {
					content: [
						{
							type: "text",
							text: `Connected MCP Servers (${connections.length}):\n\n${connectionList}`,
						},
					],
				};
			},
		);

		// Tool 14: Call a tool on a connected MCP server
		this.server.tool(
			"call_mcp_tool",
			{
				serverName: z.string().describe("Name of the connected MCP server"),
				toolName: z.string().describe("Name of the tool to call"),
				arguments: z.record(z.any()).default({}).describe("Arguments to pass to the tool"),
			},
			async ({ serverName, toolName, arguments: args }) => {
				try {
					// Get connection info
					const connection = this.sql<{
						name: string;
						url: string;
						status: string;
					}>`SELECT * FROM mcp_client_connections WHERE name = ${serverName} LIMIT 1`;

					if (connection.length === 0) {
						return {
							content: [
								{
									type: "text",
									text: `Error: No connection found with name '${serverName}'. Use connect_to_mcp_server first.`,
								},
							],
						};
					}

					if (connection[0].status !== "connected") {
						return {
							content: [
								{
									type: "text",
									text: `Error: Connection '${serverName}' is not active (status: ${connection[0].status}). Try reconnecting.`,
								},
							],
						};
					}

					// Call the tool using MCPClientManager
					const result = await this.mcp.callTool({
						serverId: connection[0].url,
						name: toolName,
						arguments: args,
					});

					// Update last sync time
					this.sql`
						UPDATE mcp_client_connections
						SET last_sync = ${Date.now()}
						WHERE name = ${serverName}
					`;

					return {
						content: [
							{
								type: "text",
								text: `Result from ${serverName}.${toolName}:\n\n${JSON.stringify(result, null, 2)}`,
							},
						],
					};
				} catch (error) {
					return {
						content: [
							{
								type: "text",
								text: `Error calling tool '${toolName}' on server '${serverName}': ${error instanceof Error ? error.message : String(error)}`,
							},
						],
					};
				}
			},
		);
	}

	// State update handler
	onStateUpdate(state: MetaMCPState | undefined, source: Connection | "server"): void {
		console.log("State updated from:", source === "server" ? "server" : "client connection");
		// Clients connected via SSE will automatically receive state updates
	}

	// Database initialization
	private async initializeDatabase(): Promise<void> {
		if (this.isDbInitialized) return;

		// Create mcp_servers table
		this.sql`
			CREATE TABLE IF NOT EXISTS mcp_servers (
				id TEXT PRIMARY KEY,
				name TEXT NOT NULL UNIQUE,
				version TEXT NOT NULL,
				description TEXT NOT NULL,
				created_at INTEGER NOT NULL,
				updated_at INTEGER NOT NULL,
				wrangler_config TEXT NOT NULL
			)
		`;

		// Create mcp_tools table
		this.sql`
			CREATE TABLE IF NOT EXISTS mcp_tools (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				server_id TEXT NOT NULL,
				name TEXT NOT NULL,
				description TEXT NOT NULL,
				parameters TEXT NOT NULL,
				implementation TEXT NOT NULL,
				created_at INTEGER NOT NULL,
				FOREIGN KEY (server_id) REFERENCES mcp_servers(id) ON DELETE CASCADE,
				UNIQUE(server_id, name)
			)
		`;

		// Create mcp_resources table
		this.sql`
			CREATE TABLE IF NOT EXISTS mcp_resources (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				server_id TEXT NOT NULL,
				uri TEXT NOT NULL,
				name TEXT NOT NULL,
				description TEXT NOT NULL,
				mime_type TEXT NOT NULL,
				implementation TEXT NOT NULL,
				created_at INTEGER NOT NULL,
				FOREIGN KEY (server_id) REFERENCES mcp_servers(id) ON DELETE CASCADE,
				UNIQUE(server_id, uri)
			)
		`;

		// Create mcp_prompts table
		this.sql`
			CREATE TABLE IF NOT EXISTS mcp_prompts (
				id INTEGER PRIMARY KEY AUTOINCREMENT,
				server_id TEXT NOT NULL,
				name TEXT NOT NULL,
				description TEXT NOT NULL,
				arguments TEXT NOT NULL,
				template TEXT NOT NULL,
				created_at INTEGER NOT NULL,
				FOREIGN KEY (server_id) REFERENCES mcp_servers(id) ON DELETE CASCADE,
				UNIQUE(server_id, name)
			)
		`;

		// Create cleanup_requests table
		this.sql`
			CREATE TABLE IF NOT EXISTS cleanup_requests (
				id TEXT PRIMARY KEY,
				requested_at INTEGER NOT NULL,
				servers_to_delete TEXT NOT NULL,
				status TEXT NOT NULL,
				responded_at INTEGER
			)
		`;

		// Create mcp_client_connections table
		this.sql`
			CREATE TABLE IF NOT EXISTS mcp_client_connections (
				id TEXT PRIMARY KEY,
				name TEXT NOT NULL UNIQUE,
				url TEXT NOT NULL,
				status TEXT NOT NULL,
				last_sync INTEGER NOT NULL,
				capabilities TEXT,
				tools_count INTEGER DEFAULT 0,
				resources_count INTEGER DEFAULT 0,
				created_at INTEGER NOT NULL
			)
		`;

		// Create indexes
		this.sql`CREATE INDEX IF NOT EXISTS idx_mcp_tools_server_id ON mcp_tools(server_id)`;
		this.sql`CREATE INDEX IF NOT EXISTS idx_mcp_resources_server_id ON mcp_resources(server_id)`;
		this.sql`CREATE INDEX IF NOT EXISTS idx_mcp_prompts_server_id ON mcp_prompts(server_id)`;
		this.sql`CREATE INDEX IF NOT EXISTS idx_cleanup_status ON cleanup_requests(status, requested_at)`;
		this.sql`CREATE INDEX IF NOT EXISTS idx_mcp_servers_updated ON mcp_servers(updated_at)`;
		this.sql`CREATE INDEX IF NOT EXISTS idx_mcp_connections_status ON mcp_client_connections(status)`;

		this.isDbInitialized = true;
	}

	// SQL helper methods for CRUD operations
	private async getServerFromDB(serverId: string): Promise<MCPServerConfig | null> {
		const serverRows = this.sql<DatabaseSchema["mcp_servers"]>`
			SELECT * FROM mcp_servers WHERE id = ${serverId}
		`;

		if (serverRows.length === 0) return null;

		const server = serverRows[0];

		const tools = this.sql<DatabaseSchema["mcp_tools"]>`
			SELECT * FROM mcp_tools WHERE server_id = ${serverId}
		`.map((t) => ({
			name: t.name,
			description: t.description,
			parameters: JSON.parse(t.parameters),
			implementation: t.handler_code || t.implementation,
		}));

		const resources = this.sql<DatabaseSchema["mcp_resources"]>`
			SELECT * FROM mcp_resources WHERE server_id = ${serverId}
		`.map((r) => ({
			uri: r.uri,
			name: r.name,
			description: r.description,
			mimeType: r.mime_type,
			implementation: r.implementation,
		}));

		const prompts = this.sql<DatabaseSchema["mcp_prompts"]>`
			SELECT * FROM mcp_prompts WHERE server_id = ${serverId}
		`.map((p) => ({
			name: p.name,
			description: p.description,
			arguments: JSON.parse(p.arguments),
			template: p.template,
		}));

		return {
			name: server.name,
			version: server.version,
			description: server.description,
			tools,
			resources,
			prompts,
			wranglerConfig: JSON.parse(server.wrangler_config),
			createdAt: server.created_at,
			updatedAt: server.updated_at,
		};
	}

	private async saveServerToDB(serverId: string, config: MCPServerConfig): Promise<void> {
		// Insert or update server
		this.sql`
			INSERT INTO mcp_servers (id, name, version, description, created_at, updated_at, wrangler_config)
			VALUES (${serverId}, ${config.name}, ${config.version}, ${config.description},
					${config.createdAt}, ${config.updatedAt}, ${JSON.stringify(config.wranglerConfig)})
			ON CONFLICT(id) DO UPDATE SET
				version = ${config.version},
				description = ${config.description},
				updated_at = ${config.updatedAt},
				wrangler_config = ${JSON.stringify(config.wranglerConfig)}
		`;

		// Delete existing tools/resources/prompts for this server
		this.sql`DELETE FROM mcp_tools WHERE server_id = ${serverId}`;
		this.sql`DELETE FROM mcp_resources WHERE server_id = ${serverId}`;
		this.sql`DELETE FROM mcp_prompts WHERE server_id = ${serverId}`;

		// Insert tools
		for (const tool of config.tools) {
			this.sql`
				INSERT INTO mcp_tools (server_id, name, description, parameters, implementation, handler_code, created_at)
				VALUES (${serverId}, ${tool.name}, ${tool.description}, ${JSON.stringify(tool.parameters)},
						${tool.implementation}, ${tool.implementation}, ${Date.now()})
			`;
		}

		// Insert resources
		for (const resource of config.resources) {
			this.sql`
				INSERT INTO mcp_resources (server_id, uri, name, description, mime_type, implementation, created_at)
				VALUES (${serverId}, ${resource.uri}, ${resource.name}, ${resource.description},
						${resource.mimeType}, ${resource.implementation}, ${Date.now()})
			`;
		}

		// Insert prompts
		for (const prompt of config.prompts) {
			this.sql`
				INSERT INTO mcp_prompts (server_id, name, description, arguments, template, created_at)
				VALUES (${serverId}, ${prompt.name}, ${prompt.description}, ${JSON.stringify(prompt.arguments)},
						${prompt.template}, ${Date.now()})
			`;
		}
	}

	private async deleteServerFromDB(serverId: string): Promise<boolean> {
		const result = this.sql`DELETE FROM mcp_servers WHERE id = ${serverId}`;
		return result.length > 0;
	}

	private async listServersFromDB(): Promise<MCPServerConfig[]> {
		const serverRows = this.sql<DatabaseSchema["mcp_servers"]>`SELECT * FROM mcp_servers`;

		const servers: MCPServerConfig[] = [];
		for (const server of serverRows) {
			const config = await this.getServerFromDB(server.id);
			if (config) servers.push(config);
		}

		return servers;
	}

	// State update helpers
	private async updateServerStats(): Promise<void> {
		const servers = await this.listServersFromDB();

		let totalTools = 0;
		let totalResources = 0;
		let totalPrompts = 0;

		for (const server of servers) {
			totalTools += server.tools.length;
			totalResources += server.resources.length;
			totalPrompts += server.prompts.length;
		}

		const newState: Partial<MetaMCPState> = {
			totalServers: servers.length,
			totalTools,
			totalResources,
			totalPrompts,
			lastHealthCheck: Date.now(),
			databaseHealth: "healthy",
		};

		this.setState({ ...this.state, ...newState });
	}

	private async notifyServerCreated(name: string): Promise<void> {
		await this.updateServerStats();
		this.setState({
			...this.state,
			lastServerCreated: { name, timestamp: Date.now() },
		});
	}

	private async notifyServerUpdated(name: string): Promise<void> {
		await this.updateServerStats();
		this.setState({
			...this.state,
			lastServerUpdated: { name, timestamp: Date.now() },
		});
	}

	private async notifyServerDeleted(name: string): Promise<void> {
		await this.updateServerStats();
		this.setState({
			...this.state,
			lastServerDeleted: { name, timestamp: Date.now() },
		});
	}

	// Helper method to generate index.ts
	private generateIndexTs(config: MCPServerConfig): string {
		const toolImplementations = config.tools
			.map((tool) => {
				const zodParams = Object.entries(tool.parameters)
					.map(([key, value]: [string, any]) => {
						let zodType = "z.string()";
						if (value.type === "number") zodType = "z.number()";
						if (value.type === "boolean") zodType = "z.boolean()";
						if (value.type === "array") zodType = "z.array(z.any())";
						if (value.type === "object") zodType = "z.record(z.any())";

						if (value.description) {
							zodType += `.describe("${value.description}")`;
						}
						if (value.optional) {
							zodType += ".optional()";
						}
						if (value.default !== undefined) {
							zodType += `.default(${JSON.stringify(value.default)})`;
						}

						return `${key}: ${zodType}`;
					})
					.join(",\n\t\t\t");

				return `
		// ${tool.description}
		this.server.tool(
			"${tool.name}",
			{
				${zodParams}
			},
			async (params) => {
				try {
					${tool.implementation}
				} catch (error) {
					return {
						content: [{
							type: "text",
							text: \`Error: \${error instanceof Error ? error.message : String(error)}\`
						}]
					};
				}
			}
		);`;
			})
			.join("\n");

		const resourceImplementations = config.resources
			.map((resource) => {
				return `
		// Resource: ${resource.name}
		this.server.resource(
			"${resource.uri}",
			{
				name: "${resource.name}",
				description: "${resource.description}",
				mimeType: "${resource.mimeType}"
			},
			async () => {
				try {
					${resource.implementation}
				} catch (error) {
					return {
						contents: [{
							uri: "${resource.uri}",
							mimeType: "text/plain",
							text: \`Error: \${error instanceof Error ? error.message : String(error)}\`
						}]
					};
				}
			}
		);`;
			})
			.join("\n");

		const promptImplementations = config.prompts
			.map((prompt) => {
				const promptArgs = prompt.arguments
					.map(
						(arg) =>
							`{
					name: "${arg.name}",
					description: "${arg.description}",
					required: ${arg.required}
				}`,
					)
					.join(",\n\t\t\t");

				return `
		// Prompt: ${prompt.name}
		this.server.prompt(
			"${prompt.name}",
			{
				description: "${prompt.description}",
				arguments: [
					${promptArgs}
				]
			},
			async (args) => {
				let template = \`${prompt.template}\`;
				for (const [key, value] of Object.entries(args)) {
					template = template.replace(new RegExp(\`{{\\\\s*\${key}\\\\s*}}\`, 'g'), String(value));
				}
				return {
					messages: [{
						role: "user",
						content: { type: "text", text: template }
					}]
				};
			}
		);`;
			})
			.join("\n");

		return `import { McpAgent } from "agents/mcp";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

// ${config.description}
export class ${this.toPascalCase(config.name)} extends McpAgent {
	server = new McpServer({
		name: "${config.name}",
		version: "${config.version}",
	});

	async init() {${toolImplementations}${resourceImplementations}${promptImplementations}
	}
}

export default {
	fetch(request: Request, env: Env, ctx: ExecutionContext) {
		const url = new URL(request.url);

		if (url.pathname === "/sse" || url.pathname === "/sse/message") {
			return ${this.toPascalCase(config.name)}.serveSSE("/sse").fetch(request, env, ctx);
		}

		if (url.pathname === "/mcp") {
			return ${this.toPascalCase(config.name)}.serve("/mcp").fetch(request, env, ctx);
		}

		return new Response("Not found", { status: 404 });
	},
};
`;
	}

	// Helper method to generate wrangler.jsonc
	private generateWranglerConfig(config: MCPServerConfig): string {
		const className = this.toPascalCase(config.name);
		const wranglerConfig = {
			$schema: "node_modules/wrangler/config-schema.json",
			name: config.wranglerConfig.name,
			main: "src/index.ts",
			compatibility_date: config.wranglerConfig.compatibilityDate,
			compatibility_flags: config.wranglerConfig.compatibilityFlags,
			...(config.wranglerConfig.routes && { routes: config.wranglerConfig.routes }),
			...(config.wranglerConfig.vars && { vars: config.wranglerConfig.vars }),
			migrations: [
				{
					new_sqlite_classes: [className],
					tag: "v1",
				},
			],
			durable_objects: {
				bindings: [
					{
						class_name: className,
						name: "MCP_OBJECT",
					},
				],
			},
			observability: {
				enabled: true,
			},
		};

		return JSON.stringify(wranglerConfig, null, "\t");
	}

	// Helper method to generate package.json
	private generatePackageJson(config: MCPServerConfig): string {
		const packageJson = {
			name: config.name,
			version: config.version,
			description: config.description,
			private: true,
			scripts: {
				deploy: "wrangler deploy",
				dev: "wrangler dev",
				format: "biome format --write",
				"lint:fix": "biome lint --fix",
				start: "wrangler dev",
				"cf-typegen": "wrangler types",
				"type-check": "tsc --noEmit",
			},
			dependencies: {
				"@modelcontextprotocol/sdk": "1.17.3",
				agents: "^0.0.113",
				zod: "^3.25.76",
			},
			devDependencies: {
				"@biomejs/biome": "^2.2.2",
				typescript: "5.9.2",
				wrangler: "^4.33.1",
			},
		};

		return JSON.stringify(packageJson, null, 2);
	}

	// Helper to convert kebab-case to PascalCase
	private toPascalCase(str: string): string {
		return str
			.split("-")
			.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
			.join("");
	}
}

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext) {
		// CORS headers for all responses
		const corsHeaders = {
			"Access-Control-Allow-Origin": "*",
			"Access-Control-Allow-Methods": "GET, POST, OPTIONS",
			"Access-Control-Allow-Headers": "Content-Type, Authorization, CF-Access-JWT-Assertion",
			"Access-Control-Max-Age": "86400",
		};

		try {
			const url = new URL(request.url);

			// Handle OPTIONS preflight requests
			if (request.method === "OPTIONS") {
				return new Response(null, {
					status: 204,
					headers: corsHeaders,
				});
			}

			// Health check endpoint (no auth required)
			if (url.pathname === "/health" || url.pathname === "/ping") {
				return new Response(
					JSON.stringify({
						status: "ok",
						server: "MCP Remote Server Builder",
						version: "1.0.0",
						timestamp: new Date().toISOString(),
					}),
					{
						status: 200,
						headers: {
							"Content-Type": "application/json",
							...corsHeaders,
						},
					},
				);
			}

			// Root endpoint with server info (no auth required)
			if (url.pathname === "/") {
				return new Response(
					JSON.stringify(
						{
							name: "MCP Remote Server Builder",
							version: "1.0.0",
							description:
								"Meta-MCP Server for creating and deploying MCP Remote Servers",
							endpoints: {
								sse: "/sse (Server-Sent Events transport)",
								mcp: "/mcp (HTTP POST transport)",
								health: "/health (Health check)",
								message: "/sse/message (SSE message endpoint)",
							},
							documentation: "https://github.com/myselfgus/remote-mcp-server-authless",
							authentication: env.CF_ACCESS_ENABLED !== "false" ? "enabled" : "disabled",
							usage: {
								claude_desktop:
									'Add to config: { "command": "npx", "args": ["mcp-remote", "URL/sse"] }',
								direct_connection: "Connect to /sse endpoint for Server-Sent Events",
							},
						},
						null,
						2,
					),
					{
						status: 200,
						headers: {
							"Content-Type": "application/json",
							...corsHeaders,
						},
					},
				);
			}

			// Cloudflare Access configuration
			// Note: When CF_ACCESS_ENABLED=true, you MUST configure Cloudflare Access
			// in the dashboard for domain meta-mcp.voither.workers.dev
			// The dashboard Access handles ALL authentication - the Worker just passes requests through
			const accessConfig: CloudflareAccessConfig = {
				enabled: env.CF_ACCESS_ENABLED !== "false", // Default to enabled
			};

			// Note: No validation needed in Worker when Cloudflare Access is enabled in dashboard
			// Access intercepts requests BEFORE they reach the Worker
			const authError = await validateCloudflareAccess(request, accessConfig);
			if (authError) {
				return authError;
			}

			// Process MCP requests with CORS
			if (url.pathname === "/sse" || url.pathname === "/sse/message") {
				const response = await MetaMCP.serveSSE("/sse").fetch(request, env, ctx);
				// Add CORS headers to SSE response
				const newHeaders = new Headers(response.headers);
				Object.entries(corsHeaders).forEach(([key, value]) => {
					newHeaders.set(key, value);
				});
				return new Response(response.body, {
					status: response.status,
					statusText: response.statusText,
					headers: newHeaders,
				});
			}

			if (url.pathname === "/mcp") {
				const response = await MetaMCP.serve("/mcp").fetch(request, env, ctx);
				// Add CORS headers to MCP response
				const newHeaders = new Headers(response.headers);
				Object.entries(corsHeaders).forEach(([key, value]) => {
					newHeaders.set(key, value);
				});
				return new Response(response.body, {
					status: response.status,
					statusText: response.statusText,
					headers: newHeaders,
				});
			}

			return new Response("Not found", {
				status: 404,
				headers: {
					"Content-Type": "text/plain",
					...corsHeaders,
				},
			});
		} catch (error) {
			console.error("Worker error:", error);
			return new Response(
				JSON.stringify({
					error: "Internal server error",
					message: error instanceof Error ? error.message : String(error),
					timestamp: new Date().toISOString(),
				}),
				{
					status: 500,
					headers: {
						"Content-Type": "application/json",
						...corsHeaders,
					},
				},
			);
		}
	},
};
